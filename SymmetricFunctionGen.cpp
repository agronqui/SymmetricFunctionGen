// SymmetricFunctionGen.cpp  - Copyright 2015 Addy Gronquist
//  Generate a .plz file containing every minterm of the Symmetric Boolean Function 
//   Fs(N,S), given the number of variables N and the set S of the numbers of true inputs 
//   comprising the given symmetric function.
//
//   Example: 'SymmetricFunctionGen.exe 3 "{0,2,3}" '  would generate the pla file:
//       
//      ## Symmetric Function S3({0,2,3}), generated by SymmetricFunctionGen.exe:
//      .i 3
//      .o 1
//      .p 5
//  
//      000 1
//      011 1
//      101 1
//      110 1
//      111 1
//      .e


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include <boost/filesystem.hpp>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include "BooleanPerms.h"



int dirExists(const char *path)
{
    struct stat info;

    printf("ADDY-8715: chekcing outfile...\n");
    if(stat( path, &info ) != 0) {
        printf("ADDY-8721: \n");
        return 0;
    }
    else if(info.st_mode & S_IFDIR) {
        printf("ADDY-8722: \n");
        return 1;
    }
    else {
        printf("ADDY-8723: \n");
        return 0;
    }
}


int main(int argc, char ** argv) {
    int nvars  = 0;
    int npos   = 0; 
    int nSSets = 0;
    int setCount = 0;
    int onsetClassesLen = 0;
    long long int numPerms = 0;
    int *SSets; 
    char *parser;
    char *argv2copy;
    char *outFileName;
    FILE *outFile;

    if (argc < 4) {
        printf("usage: SymmetricFunctionGen.exe <#-of-variables> <onsetSymmetryClasses> <outFile>\n");
        printf("  Example: SymmetricFunctionGen.exe 3 \"{0,2,3}\" S3-023.pla \n");
        exit(-1);
    }

    // parse inputs
    nvars = atoi(argv[1]);
    onsetClassesLen = strlen(argv[2]);
    printf("onsetClassesLen = %d \n", onsetClassesLen);
    if ((argv[2][0] != '{') || (argv[2][onsetClassesLen-1] != '}')) {
        printf("Error 2: <onsetSymmetryClasses> input has incorrect format: must start with \"{ and end with }\", exiting...\n");
        exit(-2);
    }
    // parse output file name and open it for writing

    if (dirExists(argv[3])) {
        printf("Warning: outFile exists already...overwriting...\n");
    }
    outFile = fopen( argv[3], "w");
    printf("ADDY-114: %p\n", outFile);
    if (outFile == NULL) {
        printf("Error 4: cannot open %p\n", outFile);
    }

    
    argv[2][onsetClassesLen-1] =  0;
    printf("ADDY-115: %s \n",argv[2]+1);
    argv2copy = (char*) malloc(sizeof(char) * onsetClassesLen); 
    strcpy(argv2copy, argv[2]+1);

    // count number of sets
    parser = strtok(argv[2]+1, " ,");
    while (parser != NULL) {
        nSSets++;
        parser = strtok(NULL, " ,");
    }
    printf("ADDY-124: %d \n", nSSets);

    SSets = (int*)malloc(sizeof(int) * nSSets);

    // now parse the actual SSets values from the command line.
    parser = strtok(argv2copy, " ,");
    while (parser != NULL) {
        printf("token = %s, index = %d \n", parser, setCount);
        try {
            SSets[setCount] = atoi(parser);
        } catch (int e) {
            printf("Error 3: Symmetry Class token: %s is not an integer, exiting...\n",parser);
            exit(-3);
        }
        parser = strtok(NULL, " ,");
        setCount++;
    }

    // calculate the .o value by summing the number of combs in all the SymClasses
    for (int j = 0 ; j < nSSets ; j++) {
        numPerms += GenAllBooleanPermutations(nvars, SSets[j], false, NULL);
    }

    printf("ADDY-224: %lld\n", numPerms);
    fprintf(outFile, ".i %d\n", nvars);
    fprintf(outFile, ".o %d\n", 1);   //single output only for now
    fprintf(outFile, ".p %lld\n", numPerms);
    

    for (int i = 0; i < nSSets ; i++) {
        printf("SSets[%d] = %d \n", i, SSets[i]);
        GenAllBooleanPermutations( nvars, SSets[i], true, outFile);
    }

    fclose(outFile);

    return 0;
}
